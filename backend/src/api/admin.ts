/**
 * ç®¡ç†è€…ç”¨APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
 * 
 * ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ãƒ‡ãƒ¼ã‚¿æ›´æ–°ãªã©ã®ç®¡ç†æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚
 * æœ¬ç•ªç’°å¢ƒã§ã¯èªè¨¼ã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
 */

import { Hono } from 'hono';
import { getDatabase } from '../db/database';
import { importFoodData } from '../scripts/importFoodData';
import { generateAllMealPatterns } from '../scripts/generateMealPatterns';

/**
 * ç®¡ç†è€…APIã®ãƒ«ãƒ¼ã‚¿ãƒ¼
 */
export const adminRouter = new Hono();

/**
 * ç°¡æ˜“èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
 * 
 * æœ¬ç•ªç’°å¢ƒã§ã¯é©åˆ‡ãªèªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã«ç½®ãæ›ãˆã¦ãã ã•ã„
 * ç¾åœ¨ã¯ç’°å¢ƒå¤‰æ•° ADMIN_TOKEN ã§ã®ç°¡æ˜“èªè¨¼
 */
adminRouter.use('*', async (c, next) => {
  const authHeader = c.req.header('Authorization');
  const adminToken = process.env.ADMIN_TOKEN || 'dev-token-123';
  
  if (!authHeader || !authHeader.includes(adminToken)) {
    return c.json({ error: 'èªè¨¼ãŒå¿…è¦ã§ã™' }, 401);
  }
  
  await next();
});

/**
 * POST /api/admin/update/foods
 * æ–‡ç§‘çœãƒ‡ãƒ¼ã‚¿ã‚’æ‰‹å‹•ã§æ›´æ–°
 * 
 * ã“ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯æœ€æ–°ã®é£Ÿå“ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦
 * ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«åæ˜ ã•ã›ã¾ã™
 */
adminRouter.post('/update/foods', async (c) => {
  try {
    console.log('ğŸ“Š é£Ÿå“ãƒ‡ãƒ¼ã‚¿ã®æ›´æ–°ã‚’é–‹å§‹ã—ã¾ã™...');
    
    // ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†ã‚’å®Ÿè¡Œ
    const result = await importFoodData({
      source: 'mext',  // æ–‡ç§‘çœãƒ‡ãƒ¼ã‚¿
      forceUpdate: true
    });
    
    return c.json({
      success: true,
      message: 'é£Ÿå“ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
      result: {
        imported: result.importedCount,
        updated: result.updatedCount,
        failed: result.failedCount,
        duration: result.duration
      }
    });
    
  } catch (error) {
    console.error('é£Ÿå“ãƒ‡ãƒ¼ã‚¿æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
    return c.json({ 
      success: false,
      error: 'é£Ÿå“ãƒ‡ãƒ¼ã‚¿ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ',
      details: error.message 
    }, 500);
  }
});

/**
 * POST /api/admin/generate/meals
 * çŒ®ç«‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å†ç”Ÿæˆ
 * 
 * ã™ã¹ã¦ã®é£Ÿå“ã«å¯¾ã—ã¦çŒ®ç«‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è‡ªå‹•ç”Ÿæˆã—ã¾ã™
 */
adminRouter.post('/generate/meals', async (c) => {
  try {
    console.log('ğŸ± çŒ®ç«‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç”Ÿæˆã‚’é–‹å§‹ã—ã¾ã™...');
    
    const options = await c.req.json().catch(() => ({}));
    
    // çŒ®ç«‹ç”Ÿæˆå‡¦ç†ã‚’å®Ÿè¡Œ
    const result = await generateAllMealPatterns({
      patternsPerFood: options.patternsPerFood || 3,
      targetProtein: options.targetProtein || 20,
      clearExisting: options.clearExisting || false
    });
    
    return c.json({
      success: true,
      message: 'çŒ®ç«‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç”Ÿæˆã—ã¾ã—ãŸ',
      result: {
        generated: result.generatedCount,
        foods: result.processedFoods,
        duration: result.duration
      }
    });
    
  } catch (error) {
    console.error('çŒ®ç«‹ç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error);
    return c.json({ 
      success: false,
      error: 'çŒ®ç«‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ',
      details: error.message 
    }, 500);
  }
});

/**
 * GET /api/admin/stats
 * ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾—
 */
adminRouter.get('/stats', async (c) => {
  try {
    const db = getDatabase();
    
    // å„ç¨®çµ±è¨ˆã‚’å–å¾—
    const stats = {
      foods: {
        total: db.prepare('SELECT COUNT(*) as count FROM foods').get()?.count || 0,
        categories: db.prepare('SELECT COUNT(DISTINCT category) as count FROM foods').get()?.count || 0,
        avgProtein: db.prepare('SELECT AVG(protein) as avg FROM foods').get()?.avg || 0
      },
      mealPatterns: {
        total: db.prepare('SELECT COUNT(*) as count FROM meal_patterns').get()?.count || 0,
        autoGenerated: db.prepare('SELECT COUNT(*) as count FROM meal_patterns WHERE is_auto_generated = 1').get()?.count || 0,
        avgProtein: db.prepare('SELECT AVG(total_protein) as avg FROM meal_patterns').get()?.avg || 0
      },
      updateHistory: db.prepare('SELECT * FROM update_history ORDER BY created_at DESC LIMIT 5').all()
    };
    
    return c.json(stats);
    
  } catch (error) {
    console.error('çµ±è¨ˆå–å¾—ã‚¨ãƒ©ãƒ¼:', error);
    return c.json({ error: 'çµ±è¨ˆæƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ' }, 500);
  }
});

/**
 * DELETE /api/admin/clear/meals
 * è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸçŒ®ç«‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã‚¯ãƒªã‚¢
 * 
 * æ‰‹å‹•ã§ä½œæˆã•ã‚ŒãŸçŒ®ç«‹ã¯å‰Šé™¤ã•ã‚Œã¾ã›ã‚“
 */
adminRouter.delete('/clear/meals', async (c) => {
  try {
    const db = getDatabase();
    
    // è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸçŒ®ç«‹ã®ã¿å‰Šé™¤
    const result = db.prepare(`
      DELETE FROM meal_patterns 
      WHERE is_auto_generated = 1
    `).run();
    
    return c.json({
      success: true,
      message: `${result.changes}å€‹ã®è‡ªå‹•ç”ŸæˆçŒ®ç«‹ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`
    });
    
  } catch (error) {
    console.error('çŒ®ç«‹å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
    return c.json({ error: 'çŒ®ç«‹ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ' }, 500);
  }
});

/**
 * GET /api/admin/health
 * ã‚·ã‚¹ãƒ†ãƒ ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
 */
adminRouter.get('/health', async (c) => {
  try {
    const db = getDatabase();
    
    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šç¢ºèª
    const dbCheck = db.prepare('SELECT 1').get();
    
    // ãƒ‡ã‚£ã‚¹ã‚¯ä½¿ç”¨é‡ç¢ºèªï¼ˆãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºï¼‰
    const dbPath = process.env.DATABASE_PATH || './data/asatan.db';
    const stats = await Bun.file(dbPath).exists();
    
    return c.json({
      status: 'healthy',
      database: dbCheck ? 'connected' : 'disconnected',
      dbFileExists: stats,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    return c.json({
      status: 'unhealthy',
      error: error.message,
      timestamp: new Date().toISOString()
    }, 500);
  }
});