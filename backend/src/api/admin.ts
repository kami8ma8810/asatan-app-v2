/**
 * 管理者用APIエンドポイント
 * 
 * このモジュールはデータ更新などの管理機能を提供します。
 * 本番環境では認証を実装する必要があります。
 */

import { Hono } from 'hono';
import { getDatabase } from '../db/database';
import { importFoodData } from '../scripts/importFoodData';
import { generateAllMealPatterns } from '../scripts/generateMealPatterns';

/**
 * 管理者APIのルーター
 */
export const adminRouter = new Hono();

/**
 * 簡易認証ミドルウェア
 * 
 * 本番環境では適切な認証システムに置き換えてください
 * 現在は環境変数 ADMIN_TOKEN での簡易認証
 */
adminRouter.use('*', async (c, next) => {
  const authHeader = c.req.header('Authorization');
  const adminToken = process.env.ADMIN_TOKEN || 'dev-token-123';
  
  if (!authHeader || !authHeader.includes(adminToken)) {
    return c.json({ error: '認証が必要です' }, 401);
  }
  
  await next();
});

/**
 * POST /api/admin/update/foods
 * 文科省データを手動で更新
 * 
 * このエンドポイントは最新の食品データをダウンロードして
 * データベースに反映させます
 */
adminRouter.post('/update/foods', async (c) => {
  try {
    console.log('📊 食品データの更新を開始します...');
    
    // インポート処理を実行
    const result = await importFoodData({
      source: 'mext',  // 文科省データ
      forceUpdate: true
    });
    
    return c.json({
      success: true,
      message: '食品データを更新しました',
      result: {
        imported: result.importedCount,
        updated: result.updatedCount,
        failed: result.failedCount,
        duration: result.duration
      }
    });
    
  } catch (error) {
    console.error('食品データ更新エラー:', error);
    return c.json({ 
      success: false,
      error: '食品データの更新に失敗しました',
      details: error.message 
    }, 500);
  }
});

/**
 * POST /api/admin/generate/meals
 * 献立パターンを再生成
 * 
 * すべての食品に対して献立パターンを自動生成します
 */
adminRouter.post('/generate/meals', async (c) => {
  try {
    console.log('🍱 献立パターンの生成を開始します...');
    
    const options = await c.req.json().catch(() => ({}));
    
    // 献立生成処理を実行
    const result = await generateAllMealPatterns({
      patternsPerFood: options.patternsPerFood || 3,
      targetProtein: options.targetProtein || 20,
      clearExisting: options.clearExisting || false
    });
    
    return c.json({
      success: true,
      message: '献立パターンを生成しました',
      result: {
        generated: result.generatedCount,
        foods: result.processedFoods,
        duration: result.duration
      }
    });
    
  } catch (error) {
    console.error('献立生成エラー:', error);
    return c.json({ 
      success: false,
      error: '献立パターンの生成に失敗しました',
      details: error.message 
    }, 500);
  }
});

/**
 * GET /api/admin/stats
 * データベースの統計情報を取得
 */
adminRouter.get('/stats', async (c) => {
  try {
    const db = getDatabase();
    
    // 各種統計を取得
    const stats = {
      foods: {
        total: db.prepare('SELECT COUNT(*) as count FROM foods').get()?.count || 0,
        categories: db.prepare('SELECT COUNT(DISTINCT category) as count FROM foods').get()?.count || 0,
        avgProtein: db.prepare('SELECT AVG(protein) as avg FROM foods').get()?.avg || 0
      },
      mealPatterns: {
        total: db.prepare('SELECT COUNT(*) as count FROM meal_patterns').get()?.count || 0,
        autoGenerated: db.prepare('SELECT COUNT(*) as count FROM meal_patterns WHERE is_auto_generated = 1').get()?.count || 0,
        avgProtein: db.prepare('SELECT AVG(total_protein) as avg FROM meal_patterns').get()?.avg || 0
      },
      updateHistory: db.prepare('SELECT * FROM update_history ORDER BY created_at DESC LIMIT 5').all()
    };
    
    return c.json(stats);
    
  } catch (error) {
    console.error('統計取得エラー:', error);
    return c.json({ error: '統計情報の取得に失敗しました' }, 500);
  }
});

/**
 * DELETE /api/admin/clear/meals
 * 自動生成された献立パターンをクリア
 * 
 * 手動で作成された献立は削除されません
 */
adminRouter.delete('/clear/meals', async (c) => {
  try {
    const db = getDatabase();
    
    // 自動生成された献立のみ削除
    const result = db.prepare(`
      DELETE FROM meal_patterns 
      WHERE is_auto_generated = 1
    `).run();
    
    return c.json({
      success: true,
      message: `${result.changes}個の自動生成献立を削除しました`
    });
    
  } catch (error) {
    console.error('献立削除エラー:', error);
    return c.json({ error: '献立の削除に失敗しました' }, 500);
  }
});

/**
 * GET /api/admin/health
 * システムヘルスチェック
 */
adminRouter.get('/health', async (c) => {
  try {
    const db = getDatabase();
    
    // データベース接続確認
    const dbCheck = db.prepare('SELECT 1').get();
    
    // ディスク使用量確認（データベースファイルサイズ）
    const dbPath = process.env.DATABASE_PATH || './data/asatan.db';
    const stats = await Bun.file(dbPath).exists();
    
    return c.json({
      status: 'healthy',
      database: dbCheck ? 'connected' : 'disconnected',
      dbFileExists: stats,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    return c.json({
      status: 'unhealthy',
      error: error.message,
      timestamp: new Date().toISOString()
    }, 500);
  }
});